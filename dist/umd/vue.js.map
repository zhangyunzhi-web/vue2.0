{"version":3,"file":"vue.js","sources":["../../src/observer/array.js","../../src/observer/index.js","../../src/state.js","../../src/init.js","../../src/index.js"],"sourcesContent":["// 拿到数组原型上原有的方法\r\nlet oldArrayProtoMethods = Array.prototype;\r\n\r\n// 继承一下   array.__proto__ = oldArrayProtoMethods\r\nexport let arrayMethods = Object.create(oldArrayProtoMethods);\r\n\r\nlet methods = [\r\n    'push',\r\n    'pop',\r\n    'shift',\r\n    'unshift',\r\n    'splice',\r\n    'reverse',\r\n    'sort'\r\n]\r\nmethods.forEach(methods => {\r\n    arrayMethods[methods] = function () {\r\n        console.log('数组方法被调用了')\r\n        const result = oldArrayProtoMethods[methods].apply(this, arguments)\r\n        switch (method) {\r\n            case 'psuh':\r\n            case 'unshift': //这两个方法都是追加，追加的内容可能是对象类型，应该被再次劫持\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        return result;\r\n    }\r\n\r\n});\r\n\r\n\r\n// arrayMethods.concat = function (){    // 没有重写的你可以沿着原型链找，他还是原来的\r\n\r\n// }","import {\r\n    arrayMethods\r\n} from \"./array\";\r\n\r\nclass Observer {\r\n    constructor(value) {\r\n        //使用defineProperty 重新定义属性\r\n        // console.log(value);\r\n        if (Array.isArray(value)) {\r\n            // 我希望调用 pop shift unshift push reverse sort splice 时，先做自己想做的事，再进行调用\r\n            // 函数劫持、切片编程\r\n            value.__proto__ = arrayMethods\r\n            // 观测数组里面的对象类型，对象发生变化也要做一些事情\r\n            this.observerArray(value)\r\n        } else {\r\n            this.walk(value);\r\n        }\r\n\r\n    }\r\n    observerArray(value) {\r\n        value.forEach(item => {\r\n            observer(item); //观测数组类型中的对象类型\r\n        })\r\n    }\r\n    walk(data) {\r\n        let keys = Object.keys(data); //获取对象的key\r\n        keys.forEach(key => {\r\n            defineReactive(data, key, data[key]); //Vue.util.defineReactive\r\n        });\r\n    }\r\n}\r\n\r\nfunction defineReactive(data, key, value) {\r\n    observer(value) //如果值是对象类型在进行观测\r\n    Object.defineProperty(data, key, {\r\n        get() {\r\n            // console.log('用户获取值了',data,key,value);\r\n            console.log('取值')\r\n            return value\r\n        },\r\n        set(newValue) {\r\n            console.log('设置值')\r\n            // console.log('用户设定值了',data,key,value)\r\n            if (newValue == value) return;\r\n            observer(newValue) //如果用户将值改为对象继续监控\r\n            value = newValue\r\n        }\r\n    })\r\n}\r\nexport function observer(data) {\r\n    //typeof null 也是对象\r\n    // 不能不是对象 并且不是null才能监控\r\n    if (typeof data !== 'object' || data == null) {\r\n        return;\r\n    }\r\n    // console.log(data)\r\n    return new Observer(data)\r\n}","//初始化状态的某个属性的扩展\r\n\r\nimport {\r\n    observer\r\n} from \"./observer/index.js\";\r\n\r\n\r\nexport function initState(vm) { //vm.$options\r\n    // console.log(vm)\r\n    const opts = vm.$options;\r\n    if (opts.props) {\r\n        initProps(vm);\r\n    }\r\n    if (opts.methods) {\r\n        initMethods(vm);\r\n    }\r\n    if (opts.data) {\r\n        initData(vm);\r\n    }\r\n    if (opts.computed) {\r\n        initComputed(vm);\r\n    }\r\n    if (opts.watch) {\r\n        initWatch(vm);\r\n    }\r\n\r\n}\r\n\r\nfunction initProps() {}\r\n\r\nfunction initMethods() {}\r\n\r\nfunction initData(vm) { //数据的初始化操作\r\n    let data = vm.$options.data\r\n    // console.log(data);\r\n    vm._data = data = typeof data == 'function' ? data.call(vm) : data\r\n    // console.log(data)\r\n\r\n    //数据的劫持方案 对象Object.defineProperty defineProperty可以重新定义get和set方法\r\n    //数组  单独处理的 \r\n    observer(data)\r\n}\r\n\r\nfunction initComputed() {}\r\n\r\nfunction initWatch() {}","//对当前初始化的操作进行初始化\r\n\r\n\r\n\r\nimport {\r\n    initState\r\n} from \"./state\";\r\n\r\nexport function initMixin(Vue) {\r\n    Vue.prototype._init = function (options) {\r\n        // console.log(options)\r\n        const vm = this;\r\n        vm.$options = options;\r\n\r\n\r\n        //初始化状态（将数据做一个初始化的劫持 当我改变数据时应该更新视图）\r\n        // vue组件中有很多状态 data props watch computed\r\n        initState(vm);\r\n        //\r\n\r\n        // vue里面核心特性  响应式数据原理\r\n        // Vue 是一个什么样的框架 MVVM\r\n\r\n        // 数据变化视图会更新，视图变化数据会被影响  (MVVM)不能跳过数据去更新视图,$ref\r\n    }\r\n}","//构造函数的原型上扩展方法\r\n\r\n\r\n//es6的类的写法  一个整体\r\n// class Vue{\r\n\r\nimport { initMixin } from \"./init\";\r\n\r\n//     a(){\r\n\r\n//     }\r\n//     b(){\r\n\r\n//     }\r\n//     c(){\r\n\r\n//     }\r\n// }\r\n\r\nfunction Vue(options){\r\n    // console.log(options)\r\n    this._init(options);//入口方法，做初始化操作\r\n}\r\n\r\n//写成一个个的插件进行对原型的扩展\r\n\r\n//初始化方法\r\n// Vue.prototype._init = function (options) {\r\n\r\n// }\r\ninitMixin(Vue)\r\n\r\nexport default Vue;"],"names":["oldArrayProtoMethods","Array","prototype","arrayMethods","Object","create","methods","forEach","console","log","result","apply","arguments","method","Observer","value","isArray","__proto__","observerArray","walk","item","observer","data","keys","key","defineReactive","defineProperty","get","set","newValue","initState","vm","opts","$options","props","initData","computed","watch","_data","call","initMixin","Vue","_init","options"],"mappings":"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"}